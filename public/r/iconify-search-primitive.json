{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "iconify-search-primitive",
  "title": "Iconify Search Primitive",
  "description": "Renderless component for Iconify icon search. Build custom UIs with search state, grouping, and selection via render props.",
  "dependencies": [
    "@tanstack/react-query",
    "@tanstack/react-pacer"
  ],
  "files": [
    {
      "path": "components/iconify-search-primitive.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\nimport { useDebouncedValue } from \"@tanstack/react-pacer\";\nimport {\n  useIconifySearch,\n  useIconifySearchAll,\n} from \"@/hooks/use-iconify-search\";\nimport { getIconUrl } from \"@/lib/iconify\";\nimport type { IconifySearchResponse } from \"@/lib/iconify\";\n\nconst DEFAULT_DEBOUNCE_MS = 300;\n\nexport interface IconifySearchStateBase {\n  /** Current raw query string */\n  query: string;\n  /** Update the search query */\n  setQuery: (value: string) => void;\n  /** Debounced query used for API calls */\n  debouncedQuery: string;\n  /** Whether the debouncer is still pending */\n  isDebouncing: boolean;\n  /** Raw search response from Iconify API */\n  data: IconifySearchResponse | undefined;\n  /** Whether the initial fetch is loading */\n  isLoading: boolean;\n  /** Whether a fetch is in progress (including refetch) */\n  isFetching: boolean;\n  /** Combined: debouncing or fetching */\n  isPending: boolean;\n  /** Currently selected icon ID (e.g. \"mdi:home\") */\n  selectedIcon: string | null;\n  /** Update the selected icon */\n  setSelectedIcon: (iconId: string | null) => void;\n  /** Helper to get Iconify CDN URL for an icon */\n  getIconUrl: (iconId: string, size?: number) => string;\n}\n\nexport interface IconifySearchStateAll extends IconifySearchStateBase {\n  mode: \"all\";\n  /** Icons grouped by collection prefix for display */\n  groups: Array<{ prefix: string; name: string; icons: string[] }>;\n}\n\nexport interface IconifySearchStatePaginated extends IconifySearchStateBase {\n  mode: \"paginated\";\n  /** Flat list of icon IDs for combobox-style UIs */\n  icons: string[];\n  fetchNextPage: () => void;\n  hasNextPage: boolean;\n  isFetchingNextPage: boolean;\n}\n\nexport type IconifySearchState =\n  | IconifySearchStateAll\n  | IconifySearchStatePaginated;\n\nexport interface IconifySearchPrimitivePropsBase {\n  /** Debounce delay in ms before triggering search */\n  debounceMs?: number;\n}\n\nexport interface IconifySearchPrimitivePropsAll\n  extends IconifySearchPrimitivePropsBase {\n  /** Fetches up to 999 icons at once (dialog) */\n  mode?: \"all\";\n  children: (state: IconifySearchStateAll) => React.ReactNode;\n}\n\nexport interface IconifySearchPrimitivePropsPaginated\n  extends IconifySearchPrimitivePropsBase {\n  /** Loads 64 then \"load more\" (combobox) */\n  mode: \"paginated\";\n  children: (state: IconifySearchStatePaginated) => React.ReactNode;\n}\n\nexport type IconifySearchPrimitiveProps =\n  | IconifySearchPrimitivePropsAll\n  | IconifySearchPrimitivePropsPaginated;\n\n/**\n * Renderless component that interfaces with the Iconify API for icon search.\n * Provides search state, grouping, selection, and URL helpers via render props.\n * Use this to build custom UI (dialogs, comboboxes, etc.) without duplicating logic.\n */\nexport function IconifySearchPrimitive({\n  mode = \"all\",\n  debounceMs = DEFAULT_DEBOUNCE_MS,\n  children,\n}: IconifySearchPrimitiveProps): React.ReactElement {\n  const [query, setQuery] = React.useState(\"\");\n  const [selectedIcon, setSelectedIcon] = React.useState<string | null>(null);\n\n  const [debouncedQuery, debouncer] = useDebouncedValue(\n    query,\n    { wait: debounceMs },\n    (s) => ({ isPending: s.isPending })\n  );\n  const isDebouncing = debouncer.state.isPending ?? false;\n\n  const allQuery = useIconifySearchAll(debouncedQuery);\n  const paginatedQuery = useIconifySearch(debouncedQuery);\n\n  const allData = allQuery.data;\n  const paginatedData = paginatedQuery.data;\n  const { isLoading, isFetching } =\n    mode === \"all\" ? allQuery : paginatedQuery;\n  const isPending = isDebouncing || isLoading || isFetching;\n  const data = mode === \"all\" ? allData : undefined;\n\n  const groups = React.useMemo(() => {\n    if (mode === \"paginated\") return [];\n    const icons = data?.icons ?? [];\n    const deduped = [...new Set(icons)];\n    const allCollections: Record<string, { name: string }> = {};\n    if (data?.collections) {\n      Object.entries(data.collections).forEach(([prefix, info]) => {\n        allCollections[prefix] = { name: info.name ?? prefix };\n      });\n    }\n    if (selectedIcon && !deduped.includes(selectedIcon)) {\n      deduped.unshift(selectedIcon);\n      const [prefix] = selectedIcon.split(\":\");\n      if (prefix && !allCollections[prefix]) {\n        allCollections[prefix] = { name: prefix };\n      }\n    }\n    const byPrefix = new Map<string, string[]>();\n    for (const iconId of deduped) {\n      const prefix = iconId.split(\":\")[0] ?? \"other\";\n      if (!byPrefix.has(prefix)) byPrefix.set(prefix, []);\n      byPrefix.get(prefix)!.push(iconId);\n    }\n    return Array.from(byPrefix.entries()).map(([prefix, icons]) => ({\n      prefix,\n      name: allCollections[prefix]?.name ?? prefix,\n      icons,\n    }));\n  }, [data, selectedIcon, mode]);\n\n  const icons = React.useMemo(() => {\n    if (mode === \"all\") return [];\n    const merged = paginatedData?.pages?.flatMap((page) => page.icons) ?? [];\n    const deduped = [...new Set(merged)];\n    if (selectedIcon && !deduped.includes(selectedIcon)) {\n      return [selectedIcon, ...deduped];\n    }\n    return deduped;\n  }, [paginatedData, selectedIcon, mode]);\n\n  const baseState: IconifySearchStateBase = {\n    query,\n    setQuery,\n    debouncedQuery,\n    isDebouncing,\n    data: mode === \"all\" ? data : undefined,\n    isLoading,\n    isFetching,\n    isPending,\n    selectedIcon,\n    setSelectedIcon,\n    getIconUrl,\n  };\n\n  const state: IconifySearchState =\n    mode === \"all\"\n      ? { ...baseState, mode: \"all\", groups }\n      : {\n          ...baseState,\n          mode: \"paginated\",\n          icons,\n          fetchNextPage: paginatedQuery.fetchNextPage,\n          hasNextPage: paginatedQuery.hasNextPage ?? false,\n          isFetchingNextPage: paginatedQuery.isFetchingNextPage ?? false,\n        };\n\n  return (\n    <>\n      {(children as (state: IconifySearchState) => React.ReactNode)(state)}\n    </>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "lib/iconify.ts",
      "content": "import type { IconifyInfo } from \"@iconify/types\";\n\nconst ICONIFY_API = \"https://api.iconify.design\";\n\nexport interface IconifySearchResponse {\n  icons: string[];\n  total: number;\n  limit: number;\n  start: number;\n  collections: Record<string, IconifyInfo>;\n  request: Record<string, string>;\n}\n\nexport async function searchIcons(\n  query: string,\n  options?: { limit?: number; start?: number }\n): Promise<IconifySearchResponse> {\n  const params = new URLSearchParams({\n    query: query.trim() || \" \",\n    limit: String(options?.limit ?? 64),\n    ...(options?.start != null && { start: String(options.start) }),\n  });\n\n  const response = await fetch(`${ICONIFY_API}/search?${params}`);\n\n  if (!response.ok) {\n    throw new Error(`Iconify API error: ${response.status}`);\n  }\n\n  return response.json();\n}\n\nexport function getIconUrl(iconId: string, size = 24): string {\n  const [prefix, name] = iconId.split(\":\");\n  if (!prefix || !name) return \"\";\n  return `https://api.iconify.design/${prefix}/${name}.svg?height=${size}`;\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "hooks/use-iconify-search.ts",
      "content": "\"use client\"\n\nimport { useInfiniteQuery, useQuery } from \"@tanstack/react-query\"\nimport {\n  searchIcons,\n  type IconifySearchResponse,\n} from \"@/lib/iconify\"\n\nconst PAGE_SIZE = 64\nconst MAX_LIMIT = 999\n\nexport function useIconifySearch(query: string) {\n  return useInfiniteQuery<IconifySearchResponse>({\n    queryKey: [\"iconify-search\", query],\n    queryFn: ({ pageParam }) =>\n      searchIcons(query, {\n        limit: pageParam === 0 ? PAGE_SIZE : MAX_LIMIT,\n      }),\n    initialPageParam: 0,\n    getNextPageParam: (lastPage, allPages) => {\n      if (allPages.length > 1) return undefined\n      if (lastPage.icons.length < lastPage.limit) return undefined\n      return 1 // load more: fetch with limit=999\n    },\n    enabled: query.trim().length > 0,\n    staleTime: 1000 * 60 * 5,\n  })\n}\n\nexport function useIconifySearchAll(query: string) {\n  return useQuery<IconifySearchResponse>({\n    queryKey: [\"iconify-search-all\", query],\n    queryFn: () => searchIcons(query, { limit: MAX_LIMIT }),\n    enabled: query.trim().length > 0,\n    staleTime: 1000 * 60 * 5,\n  })\n}\n",
      "type": "registry:hook"
    }
  ],
  "type": "registry:component"
}